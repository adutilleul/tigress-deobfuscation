%% LaTeX2e file `refs.bib'
%% generated by the `filecontents' environment
%% from source `report' on 2021/12/01.
%%

@book{HackersDelight,
author = {Warren, Henry S.},
title = {Hacker's Delight},
year = {2012},
isbn = {0321842685},
publisher = {Addison-Wesley Professional},
edition = {2nd},
abstract = {In Hackers Delight, Second Edition, Hank Warren once again compiles an irresistible collection of programming hacks: timesaving techniques, algorithms, and tricks that help programmers build more elegant and efficient software, while also gaining deeper insights into their craft. Warrens hacks are eminently practical, but theyre also intrinsically interesting, and sometimes unexpected, much like the solution to a great puzzle. They are, in a word, a delight to any programmer who is excited by the opportunity to improve. Extensive additions in this edition include A new chapter on cyclic redundancy checking (CRC), including routines for the commonly used CRC-32 code A new chapter on error correcting codes (ECC), including routines for the Hamming code More coverage of integer division by constants, including methods using only shifts and adds Computing remainders without computing a quotient More coverage of population count and counting leading zeros Array population count New algorithms for compress and expand An LRU algorithm Floating-point to/from integer conversions Approximate floating-point reciprocal square root routine A gallery of graphs of discrete functions Now with exercises and answers}
}

@inproceedings{Guinet2016AryboMC,
  title={Arybo: Manipulation, Canonicalization and Identification of Mixed Boolean-Arithmetic Symbolic Expressions},
  author={Adrien Guinet and Ninon Eyrolles and Marion Videau},
  year={2016}
}

@inproceedings {syntia,
author = {Tim Blazytko and Moritz Contag and Cornelius Aschermann and Thorsten Holz},
title = {Syntia: Synthesizing the Semantics of Obfuscated Code},
booktitle = {26th {USENIX} Security Symposium ({USENIX} Security 17)},
year = {2017},
isbn = {978-1-931971-40-9},
address = {Vancouver, BC},
pages = {643--659},
url = {https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/blazytko},
publisher = {{USENIX} Association},
month = aug,
}

@inproceedings{eyrolles,
  TITLE = {{Defeating MBA-based Obfuscation}},
  AUTHOR = {Eyrolles, Ninon and Goubin, Louis and Videau, Marion},
  URL = {https://hal.archives-ouvertes.fr/hal-01388109},
  BOOKTITLE = {{2nd International Workshop on Software PROtection}},
  ADDRESS = {Vienna, Austria},
  EDITOR = {ACM},
  YEAR = {2016},
  MONTH = Oct,
  DOI = {10.1145/2995306.2995308},
  KEYWORDS = {pattern matching ; expression simplification ; mixed boolean-arithmetic expressions ; reverse engineering ; Obfuscation},
  PDF = {https://hal.archives-ouvertes.fr/hal-01388109/file/spro05.pdf},
  HAL_ID = {hal-01388109},
  HAL_VERSION = {v1},
}

@inproceedings{decidability,
author = {Richardson, Dan and Fitch, John},
title = {The Identity Problem for Elementary Functions and Constants},
year = {1994},
isbn = {0897916387},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/190347.190429},
doi = {10.1145/190347.190429},
abstract = {A solution for a version of the identify problem is proposed for a class of functions including the elementary functions. Given f(x), g(x), defined at some point β we decide whether or not f(x) = g(x) in some neighbourhood of β. This problem is first reduced to a problem about zero equivalence of elementary constants. Then a semi algorithm is given to solve the elementary constant problem. This semi algorithm is guaranteed to give the correct answer whenever it terminates, and it terminates unless the problem being considered contains a counterexample to Schanuel's conjecture.},
booktitle = {Proceedings of the International Symposium on Symbolic and Algebraic Computation},
pages = {285–290},
numpages = {6},
location = {Oxford, United Kingdom},
series = {ISSAC '94}
}

@book{termrewriting,
author = {Baader, Franz and Nipkow, Tobias},
title = {Term Rewriting and All That},
year = {1998},
isbn = {0521455200},
publisher = {Cambridge University Press},
address = {USA}
}

@inproceedings{z3solver,
author = {De Moura, Leonardo and Bj\o{}rner, Nikolaj},
title = {Z3: An Efficient SMT Solver},
year = {2008},
isbn = {3540787992},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
pages = {337–340},
numpages = {4},
location = {Budapest, Hungary},
series = {TACAS'08/ETAPS'08}
}

@MISC{collberg,
    author = {Christian Collberg and Clark Thomborson and Douglas Low},
    title = {A Taxonomy of Obfuscating Transformations},
    year = {1997}
}

@book{knuth,
author = {Knuth, Donald E.},
title = {The Art of Computer Programming, Volume 2 (3rd Ed.): Seminumerical Algorithms},
year = {1997},
isbn = {0201896842},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@inproceedings{abstract,
author = {Cousot, Patrick and Cousot, Radhia},
title = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
year = {1977},
isbn = {9781450373500},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/512950.512973},
doi = {10.1145/512950.512973},
abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
booktitle = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {238–252},
numpages = {15},
location = {Los Angeles, California},
series = {POPL '77}
}

@InProceedings{abstract_detection,
author="Dalla Preda, Mila
and Madou, Matias
and De Bosschere, Koen
and Giacobazzi, Roberto",
editor="Johnson, Michael
and Vene, Varmo",
title="Opaque Predicates Detection by Abstract Interpretation",
booktitle="Algebraic Methodology and Software Technology",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="81--95",
abstract="Code obfuscation and software watermarking are well known techniques designed to prevent the illegal reuse of software. Code obfuscation prevents malicious reverse engineering, while software watermarking protects code from piracy. An interesting class of algorithms for code obfuscation and software watermarking relies on the insertion of opaque predicates. It turns out that attackers based on a dynamic or an hybrid static-dynamic approach are either not precise or time consuming in eliminating opaque predicates. We present an abstract interpretation-based methodology for removing opaque predicates from programs. Abstract interpretation provides the right framework for proving the correctness of our approach, together with a general methodology for designing efficient attackers for a relevant class of opaque predicates. Experimental evaluations show that abstract interpretation based attacks significantly reduce the time needed to eliminate opaque predicates.",
isbn="978-3-540-35636-3"
}

@InProceedings{concolic,
author={Bardin, Sébastien and David, Robin and Marion, Jean-Yves},
booktitle={2017 IEEE Symposium on Security and Privacy (SP)},
title={Backward-Bounded DSE: Targeting Infeasibility Questions on Obfuscated Codes},
year={2017},
volume={},
number={},
pages={633-651},
doi={10.1109/SP.2017.36}}




